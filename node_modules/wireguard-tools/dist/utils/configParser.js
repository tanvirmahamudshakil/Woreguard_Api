"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConfigString = exports.generateConfigString = void 0;
/**
 * Find a part in the string based on left hand side of '='
 * eg:
 * string === 'PrivateKey = 123456'
 * part === 'PrivateKey'
 * return value = ['123456']
 * OR
 * string === 'PrivateKey = 123456'
 * part === 'SomethingElse'
 * return value = undefined
 */
var findPartInString = function (_a) {
    var string = _a.string, part = _a.part;
    var parts = string.split('\n');
    var wantedParts = parts.filter(function (x) { return x.includes(part); });
    if (!wantedParts.length)
        return undefined;
    var values = wantedParts
        .map(function (x) { var _a, _b; return (_b = (_a = x.match(/((?<==).)(.+$)/gm)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.trim(); })
        .filter(function (x) { return x !== undefined; });
    if (!values.length)
        return undefined;
    return values;
};
/** Generate a string version of the WgConfig suitable for saving to a Wireguard Config file (wg0.conf) */
var generateConfigString = function (conf) {
    var s = [];
    var wgInterface = conf.wgInterface, peers = conf.peers;
    var address = wgInterface.address, privateKey = wgInterface.privateKey, listenPort = wgInterface.listenPort, name = wgInterface.name, dns = wgInterface.dns, mtu = wgInterface.mtu, table = wgInterface.table, preUp = wgInterface.preUp, postUp = wgInterface.postUp, preDown = wgInterface.preDown, postDown = wgInterface.postDown;
    // add interface
    s.push('[Interface]');
    if (name !== undefined)
        s.push("# Name = " + name);
    if (address !== undefined && address.length)
        s.push("Address = " + address.join(','));
    if (privateKey)
        s.push("PrivateKey = " + privateKey);
    if (listenPort)
        s.push("ListenPort = " + listenPort);
    if (dns && dns.length)
        s.push("DNS = " + dns.join(','));
    if (mtu)
        s.push("MTU = " + mtu);
    if (table)
        s.push("Table = " + table);
    if (preUp && preUp.length)
        s.push(preUp.map(function (x) { return "PreUp = " + x; }).join('\n'));
    if (postUp && postUp.length)
        s.push(postUp.map(function (x) { return "PostUp = " + x; }).join('\n'));
    if (preDown && preDown.length)
        s.push(preDown.map(function (x) { return "PreDown = " + x; }).join('\n'));
    if (postDown && postDown.length)
        s.push(postDown.map(function (x) { return "PostDown = " + x; }).join('\n'));
    // add peers
    if (peers === null || peers === void 0 ? void 0 : peers.length) {
        peers.forEach(function (peer) {
            s.push('');
            s.push('[Peer]');
            if (peer.name)
                s.push("# Name = " + peer.name);
            if (peer.publicKey)
                s.push("PublicKey = " + peer.publicKey);
            if (peer.allowedIps && peer.allowedIps.length)
                s.push("AllowedIPs = " + peer.allowedIps.join(','));
            if (peer.endpoint)
                s.push("Endpoint = " + peer.endpoint);
            if (peer.preSharedKey)
                s.push("PresharedKey = " + peer.preSharedKey);
            if (peer.persistentKeepalive)
                s.push("PersistentKeepalive = " + peer.persistentKeepalive);
        });
    }
    return s.join('\n');
};
exports.generateConfigString = generateConfigString;
/**
 * Parse a WireGuard config file (wg0.conf) into a WgConfig object for use in Javascript-land
 * If no valid interface is found in the config, it will throw an error
 * If a peer in the peers array is invalid, it will throw an error
 */
var parseConfigString = function (configString) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var interFaceReg = /\[Interface\][^\[]*/gm;
    var peerReg = /\[Peer\][^\[]*/gm;
    var interfaces = configString.match(interFaceReg);
    var interfaceString = interfaces === null || interfaces === void 0 ? void 0 : interfaces[0];
    if (!interfaceString)
        throw { code: 'no_valid_interface', message: "No interface found in config:\n" + configString };
    var maybeAddress = (_b = (_a = findPartInString({ string: interfaceString, part: 'Address' })) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.split(',');
    var address = maybeAddress ? maybeAddress.filter(function (x) { return x !== undefined; }) : undefined;
    if (!address || !address.length)
        throw { code: 'no_valid_interface', message: "No address found in config:\n" + configString };
    var privateKey = (_c = findPartInString({ string: interfaceString, part: 'PrivateKey' })) === null || _c === void 0 ? void 0 : _c[0];
    if (!privateKey)
        throw { code: 'no_valid_interface', message: "No privateKey found in config:\n" + configString };
    var maybeListenPort = (_d = findPartInString({ string: interfaceString, part: 'ListenPort' })) === null || _d === void 0 ? void 0 : _d[0];
    var listenPort = maybeListenPort ? parseInt(maybeListenPort) : undefined;
    var maybeMTU = (_e = findPartInString({ string: interfaceString, part: 'MTU' })) === null || _e === void 0 ? void 0 : _e[0];
    var mtu = maybeMTU ? parseInt(maybeMTU) : undefined;
    var maybeDns = (_g = (_f = findPartInString({ string: interfaceString, part: 'DNS' })) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.split(',').filter(function (x) { return x !== undefined; });
    var dns = (maybeDns === null || maybeDns === void 0 ? void 0 : maybeDns.length) ? maybeDns : undefined;
    var wgInterface = {
        // required keys
        address: address,
        privateKey: privateKey,
        // optional keys
        dns: dns,
        listenPort: listenPort,
        mtu: mtu,
        name: (_h = findPartInString({ string: interfaceString, part: 'Name' })) === null || _h === void 0 ? void 0 : _h[0],
        table: (_j = findPartInString({ string: interfaceString, part: 'Table' })) === null || _j === void 0 ? void 0 : _j[0],
        preUp: findPartInString({ string: interfaceString, part: 'PreUp' }),
        postUp: findPartInString({ string: interfaceString, part: 'PostUp' }),
        preDown: findPartInString({ string: interfaceString, part: 'PreDown' }),
        postDown: findPartInString({ string: interfaceString, part: 'PostDown' })
    };
    // remove any undefined keys
    var key;
    for (key in wgInterface)
        if (wgInterface[key] === undefined)
            delete wgInterface[key];
    var peerStrings = configString.match(peerReg);
    var peers = !peerStrings ? [] : peerStrings.map(function (x) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!x)
            return undefined;
        var maybeAllowedIps = (_b = (_a = findPartInString({ string: x, part: 'AllowedIPs' })) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.split(',');
        var allowedIps = maybeAllowedIps ? maybeAllowedIps.filter(function (y) { return y !== undefined; }) : undefined;
        if (!allowedIps || !allowedIps.length)
            throw { code: 'invalid_peer', message: "No allowedIps found in peer:\n" + x };
        var publicKey = (_c = findPartInString({ string: x, part: 'PublicKey' })) === null || _c === void 0 ? void 0 : _c[0];
        if (!publicKey)
            throw { code: 'invalid_peer', message: "No publicKey found in peer:\n" + x };
        var maybePersistentKeepAlive = (_d = findPartInString({ string: interfaceString, part: 'PersistentKeepalive' })) === null || _d === void 0 ? void 0 : _d[0];
        var persistentKeepalive = maybePersistentKeepAlive ? parseInt(maybePersistentKeepAlive) : undefined;
        var peer = {
            // required keys
            allowedIps: allowedIps,
            publicKey: publicKey,
            // optional keys
            persistentKeepalive: persistentKeepalive,
            name: (_e = findPartInString({ string: x, part: 'Name' })) === null || _e === void 0 ? void 0 : _e[0],
            endpoint: (_f = findPartInString({ string: x, part: 'Endpoint' })) === null || _f === void 0 ? void 0 : _f[0],
            preSharedKey: (_g = findPartInString({ string: x, part: 'PresharedKey' })) === null || _g === void 0 ? void 0 : _g[0]
        };
        // remove undefined keys
        var peerKey;
        for (peerKey in peer)
            if (peer[peerKey] === undefined)
                delete peer[peerKey];
        return peer;
    }).filter(function (x) { return x !== undefined; });
    var returnVal = {
        wgInterface: wgInterface,
        peers: peers
    };
    return returnVal;
};
exports.parseConfigString = parseConfigString;
